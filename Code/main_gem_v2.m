%% --- 现代控制理论课程设计：直流电机位置伺服系统（含状态观测器拓展） ---
%
% 本脚本将完成以下任务:
% 1. 建立直流电机的状态空间模型.
% 2. 分析开环系统的稳定性和能控性.
% 3. 使用极点配置法设计状态反馈控制器.
% 4. 使用LQR最优控制法设计状态反馈控制器.
% 5. 仿真并比较两种理想控制器性能.
% 6. (拓展) 设计状态观测器，并仿真基于观测器的控制器性能.
% 7. (拓展) 对比理想控制器与基于观测器的控制器性能.
%
clc;
clear;
close all;

%% ========================================================================
% 第一步: 系统建模与参数定义
% =========================================================================
fprintf('--- 步骤 1: 系统建模 ---\n');

% 定义系统物理参数
J = 0.01;   % 转子转动惯量 (kg.m^2)
b = 0.1;    % 粘性摩擦系数 (N.m.s)
K_t = 0.01; % 电机转矩常数 (N.m/A)
K_e = 0.01; % 反电动势常数 (V/rad/s)
R = 1;      % 电枢电阻 (Ohm)
L = 0.5;    % 电枢电感 (H)

% 建立状态空间模型
A = [0, 1, 0; 
     0, -b/J, K_t/J; 
     0, -K_e/L, -R/L];
B = [0; 0; 1/L];
C = [1, 0, 0];
D = 0;

sys_ol = ss(A, B, C, D);
fprintf('系统状态空间矩阵 A, B, C, D 定义完毕。\n\n');

%% ========================================================================
% 第二步: 开环系统分析
% =========================================================================
fprintf('--- 步骤 2: 开环系统分析 ---\n');

poles_ol = eig(A);
fprintf('开环系统极点 (A的特征值):\n');
disp(poles_ol);

Mc = ctrb(A, B);
rank_Mc = rank(Mc);
fprintf('能控性矩阵的秩: %d\n', rank_Mc);
if rank_Mc == size(A,1)
    fprintf('结论: 系统完全能控。\n\n');
else
    fprintf('结论: 系统不能控，无法进行状态反馈设计。\n\n');
    return;
end

figure('Name', '开环系统分析');
step(sys_ol);
title('开环系统阶跃响应');
xlabel('时间 (秒)');
ylabel('输出角度 (弧度)');
grid on;

%% ========================================================================
% 第三步: 控制器设计 - 方法一: 极点配置法
% =========================================================================
fprintf('--- 步骤 3: 极点配置法控制器设计 ---\n');

zeta = 0.707; 
wn = 4 / (zeta * 1); 

p1 = -zeta*wn + wn*sqrt(1-zeta^2)*1i;
p2 = conj(p1);
p3 = -5 * zeta * wn; 

poles_desired = [p1; p2; p3];
fprintf('期望配置的控制器极点:\n');
disp(poles_desired);

K1 = place(A, B, poles_desired);
fprintf('极点配置法计算得到的增益 K1:\n');
disp(K1);

Nbar1 = -1 / (C * inv(A - B*K1) * B);
fprintf('极点配置法的预补偿增益 Nbar1: %.4f\n\n', Nbar1);

%% ========================================================================
% 第四步: 控制器设计 - 方法二: LQR法
% =========================================================================
fprintf('--- 步骤 4: LQR法控制器设计 ---\n');
Q = diag([10, 1, 1]); 
R_lqr = 0.1;
K2 = lqr(A, B, Q, R_lqr);
fprintf('LQR法计算得到的增益 K2:\n');
disp(K2);
Nbar2 = -1 / (C * inv(A - B*K2) * B);
fprintf('LQR法的预补偿增益 Nbar2: %.4f\n\n', Nbar2);

%% ========================================================================
% 第五步: 理想控制器性能比较
% =========================================================================
fprintf('--- 步骤 5: 理想控制器性能比较与分析 ---\n');

sys_final_pp = ss(A - B*K1, B * Nbar1, C, D);
sys_final_lqr = ss(A - B*K2, B * Nbar2, C, D);

[y_lqr, t_lqr] = step(sys_final_lqr);
[y_pp, t_pp] = step(sys_final_pp, t_lqr);

figure('Name', '理想控制器性能对比');
plot(t_pp, y_pp, 'b-', 'LineWidth', 1.5);
hold on;
plot(t_lqr, y_lqr, 'r--', 'LineWidth', 1.5);
title('理想全状态反馈：极点配置法 vs LQR法');
xlabel('时间 (秒)');
ylabel('输出角度 (弧度)');
legend('极点配置法', 'LQR法', 'Location', 'southeast');
grid on;
hold off;

%% ========================================================================
% 第六步: 拓展一 - 状态观测器设计与仿真
% =========================================================================
fprintf('\n--- 步骤 6: 拓展一 - 状态观测器设计与仿真 ---\n');

% 1. 分析能观性
Mo = obsv(A, C);
rank_Mo = rank(Mo);
fprintf('能观性矩阵的秩: %d\n', rank_Mo);
if rank_Mo == size(A,1)
    fprintf('结论: 系统完全能观，可以设计观测器。\n\n');
else
    fprintf('结论: 系统不能观，无法设计观测器。\n\n');
    return;
end

% 2. 设计观测器增益 G
% 黄金法则: 观测器极点应比控制器极点快5-10倍，以确保估计误差快速收敛
% 错误修正: 手动指定三个互不相同的极点，以避免place函数的数学限制
poles_obs = [-20; -21; -100]; 
fprintf('期望配置的观测器极点:\n');
disp(poles_obs);

% 使用对偶原理 (A', C') 来计算增益 G
% place(A', C', p) 计算出的增益是 G'
G_T = place(A', C', poles_obs);
G = G_T'; % G 是 G' 的转置
fprintf('计算得到的观测器增益 G:\n');
disp(G);

% 3. 构建包含观测器的闭环系统 (以极点配置控制器K1为例)
% 这是一个6阶系统, 状态为 [x; e], 其中 e = x - x_hat
n = size(A, 1);
A_aug = [A - B*K1, B*K1;
         zeros(n,n), A - G*C];
B_aug = [B*Nbar1;
         zeros(n,1)];
C_aug = [C, zeros(1,n)];
D_aug = 0;

sys_aug = ss(A_aug, B_aug, C_aug, D_aug);


%% ========================================================================
% 第七步: 最终性能对比与分析
% =========================================================================
fprintf('\n--- 步骤 7: 最终性能对比与分析 ---\n');

% 1. 性能对比图：理想 vs 基于观测器
[y_aug, t_aug] = step(sys_aug, t_lqr); % 在相同时间轴上仿真

figure('Name', '最终性能对比：理想 vs 观测器');
plot(t_pp, y_pp, 'b-', 'LineWidth', 2); % 理想极点配置
hold on;
plot(t_aug, y_aug, 'g--', 'LineWidth', 2); % 基于观测器的极点配置
title('系统输出对比');
xlabel('时间 (秒)');
xlim([0,10]);
ylabel('输出角度 (弧度)');
legend('理想全状态反馈', '基于观测器的反馈', 'Location', 'southeast');
grid on;
hold off;


% 2. 状态估计效果分析
% 为了得到所有状态, 我们需要使用lsim函数
t = t_lqr; % 使用与之前相同的时间向量
u = ones(size(t)); % 输入为单位阶跃
[~, ~, x_aug] = lsim(sys_aug, u, t);

% 从6阶状态中分离出真实状态x和估计误差e
x_real = x_aug(:, 1:n);
e = x_aug(:, n+1:end);
x_hat = x_real - e; % 计算估计值 x_hat = x - e

% 绘制角速度(x2)的真实值与估计值对比图
figure('Name', '状态估计效果分析');
plot(t, x_real(:,2), 'b-', 'LineWidth', 2);
hold on;
plot(t, x_hat(:,2), 'm:', 'LineWidth', 2.5);
title('状态估计效果：角速度 (\omega)');
xlabel('时间 (秒)');
xlim([0,10]);
ylabel('角速度 (rad/s)');
legend('真实角速度', '估计角速度', 'Location', 'northeast');
grid on;
hold off;
